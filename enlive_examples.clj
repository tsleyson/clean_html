; Some useful examples in Enlive. Until now I've just been shoving them in
; comments in various files, so let's put them here instead.

; to load an html resource
(enlive/html-resource (java.net.URL. pathofresource))
; to select tags
(enlive/select source [tags to select])
; to apply a transformation
(enlive/transform resource [tags to select] transformation)
; for a list of transformations
(enlive/at source
        [tags1]
        transform1
        [tags2]
        transform2
        etc.)
; It's basically like (-> source (transform [tags1] etc.))
; But at doesn't chain the transformations; it just does each one
; separately, so if you need them to happen in order it's no good.
; Use do-> for cases like that. do-> returns a closure around your
; transformations (in a sequence) that you can apply to your nodes.
; It can be passed to clone-for, e.g., or just used like a normal
; function.
; ex.
((enlive/do-> (enlive/content "Nukem!!") (enlive/set-attr :id 22)) (enlive/select coolish [:p.P2]))
; (enlive/do-> (enlive/content "Nukem!!") (enlive/set-attr :id 22)) defines a closure that
; will replace the content of whatever nodes it's given with "Nukem!!" and set their id
; attributes to 22. Then we apply that to all the p nodes with class P2, selected from the
; resource coolish.

; Here's how to get just the children of the body tag:
(enlive/at resource [#{:html :body}] enlive/unwrap [:head] nil)
; It still has the dtd and stuff.
; Note that putting the selected tags in a set is union: if a tag fits one
; or the other or both criterion, it's chosen. Putting them in a vector is
; intersection: a tag has to fulfill both criteria to be chosen. The above
; code works because it chooses anything which is an html tag or a body tag
; or both. Before I had a vector and it didn't work because the intersection
; is empty (nothing is both an html tag and a body tag).
; A way that gets rid of the dtd:
(enlive/transform (enlive/select resource [:html :body]) [:body] enlive/unwrap)

; How to fix up toc files generated by my ofnighttoc.py script so
; they use lists instead of br tags. br tags are, as I've been
; discovering, a nightmare for working with html programmatically.
(with-open [w (clojure.java.io/writer "Of Night Book 1 toc.html")] 
  (.write w (apply str (enlive/emit* 
                        (let [listitems (enlive/select toc [:p :a])] 
                          (enlive/at toc 
                                     [:p] (enlive/substitute {:tag :ul, 
                                                              :attrs {:id "toc" 
                                                                      :style "list-style-type: none"}}) 
                                     [:ul#toc] (enlive/content (map (enlive/wrap :li) listitems))))))))

; See Of Night Book 1 toc.html in libretokindlehtml's root directory for an example output.

(pprint (enlive/transform cont [[:p enlive/first-child] [:span (enlive/but :span.T1)]] enlive/unwrap))

; Unwraps pointless span tags without hurting T1s. Since I know Libre Office uses different
; class names for the same thing, I'd rather figure out how to get rid of only spans that
; don't have either a class or an id attribute and are the first child of their enclosing p.

(pprint (enlive/transform cont 
                          [[:p enlive/first-child] 
                           [:span (enlive/but (or (enlive/attr? :class) (enlive/attr? :id)))]] 
                          enlive/unwrap))

; Picks anything with no :class or :id attribute.

; Gets rid of extra whitespace at the beginning of a paragraph. This is
; necessary because sometimes the Libre Office converter will stick in extra
; whitespace at the start of a p tag. For some unfathomable reason, if I replace
; clojure.string/replace with clojure.string/trim, it doesn't work. It does work
; if I have [:p.standard :> text-node. I can't for the life of me figure out what
; :> does.

; Update: I finally found out what it does by looking at CSS questions on Stack Overflow.
; In CSS, > is the child selector--it selects just the children of a given node, and not
; any grandchildren or deeper. e.g. given
; <div>
;  <span style="font-weight: bold">something</span>
;  <p>
;     <span style="font-style: italic">something else</span>
;  </p>
; <div>
; and I selected with div span text-node { font-size: 12; } then both something
; and something else would be affected by the style (it would select every descendant
; of the div, its children and its grandchildren, which were spans, no matter how deep
; the nesting). If I did div > span text-node instead, it would only get the spans
; directly inside a div, so something would be affected, but not something else.
; In Clojure that just becomes a keyword (because Clojure has such free syntax)
; so you get :>. (CSS also has + for when two nodes are children of the same node
; and right next to each other, but I don't think Enlive does.)
(transform chapcont [:p.standard text-node] (fn [text] (clojure.string/replace text #"^\S+?" "")))

; The original code for extract-styles
(map #(s/split % #"\{|\}") (filter #(when-not (= "" %) true) (s/split (first c1st) #"\n\t"))
; Find another way to split things without relying on \n\t being there.
; Like this: (partition 2 (split style-str #"[}{]")).
(filter #(let [[_ styles] %] (when 
     (and styles (re-find #"(font-weight:bold)|(font-style:italic)" styles)) true)) plist)
(def with-keywords (map #(let [[class style-str] %] [[(keyword class)] style-str]) needed_styles))
 
; The original version of what's in extract-styles. I unrolled everything
; with the -> macro to make it easier to read.
(map #(let [[class style-str] %] 
        [[(keyword (trim class))] style-str]) 
     (filter #(let [[_ styles] %] 
                (when (and styles 
                           (re-find #"(font-weight:bold)|(font-style:italic)" styles)) true)) 
             (partition 2 (clojure.string/split c1st #"[}{]"))))
; This works, at least in the repl.
(pprint (transform tocsnip [:#toc :li] 
                   (clone-for [elem trans] 
                              [:li] (set-attr :id (str "toc_entry_" 
                                                       (clojure.string/replace 
                                                        (:name (meta elem)) #"\s" "_"))) 
                              [:li :a] (comp (set-attr :href 
                                                       (clojure.string/replace 
                                                        (:name (meta elem)) #"\s" "_")) 
                                             (content (:name (meta elem)))))))
